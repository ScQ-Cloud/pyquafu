# (C) Copyright 2023 Beijing Academy of Quantum Information Sciences
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Union

from quafu.dagcircuits.circuit_dag import circuit_to_dag, copy_dag, dag_to_circuit
from quafu.dagcircuits.dag_circuit import DAGCircuit
from quafu.transpiler.passes.basepass import BasePass

from quafu import QuantumCircuit


class TestPass(BasePass):
    """
    TestPass is a simple pass that traverses the DAGCircuit, prints all the gates,
    and demonstrates model setting and getting.
    It is designed for educational purposes to demonstrate how to write a custom pass.
    """

    def __init__(self):
        """Initialize the TestPass."""
        super().__init__()
        self.model = None

    def set_model(self, model):
        """
        Set the model for the pass.

        Args:
            model: The model to set.
        """
        self.model = model
        print("This Pass model has been set.")
        self.print_model_info("After setting model")

    def get_model(self):
        """
        Get a new model from the pass after run the run() method.

        Returns:
            The new model generated by the pass.
        """
        return self.model

    def print_model_info(self, context, model=None):
        """
        Print information about the current model.

        Args:
            context (str): The context in which this method is called.
            model: The model to print. If None, use the instance's model.
        """
        print("-" * 100)
        model = model or self.model
        if model:
            print(f"{context} - Model: {model}")
            if isinstance(model, dict):
                print(f"{context} - Model name: {model.get('name')}")
            elif hasattr(model, "name"):
                print(f"{context} - Model name: {model.name}")
            else:
                print(f"{context} - Model name: {None}")

        else:
            print(f"{context} - No model is set.")
        print("-" * 100)

    def run(self, circ_dag: Union[QuantumCircuit, DAGCircuit]):
        """
        Run the TestPass on a DAGCircuit.

        Args:
            circ_dag (DAGCircuit or QuantumCircuit): The circuit to run the pass on.

        Returns:
            new_circuit (QuantumCircuit): The original circuit, unchanged.
        """
        print("Running TestPass on the circuit.")
        if isinstance(circ_dag, QuantumCircuit):
            dag = circuit_to_dag(circ_dag)
            circuit = circ_dag
        elif isinstance(circ_dag, DAGCircuit):
            dag = copy_dag(circ_dag)
            circuit = dag_to_circuit(circ_dag, circ_dag.circuit_qubits)
        else:
            raise TypeError(
                "Error: TestPass only supports QuantumCircuit or DAGCircuit."
            )

        # Traverse the DAG and print all gates
        print("Traversing the DAG and printing all the meaningful node gates:")
        for node in dag.nodes:
            if node == -1 or node == float("inf"):
                continue
            print(node)

        # Change the model's information
        if self.model:
            if isinstance(self.model, dict):
                # If self.model is a dictionary object, set the key-value pair directly.
                self.model["name"] = "NewModel"
            elif hasattr(self.model, "name"):
                # If self.model is an object with a name attribute
                self.model.name = "NewModel"
            else:
                # If self.model is an object, but does not have a name attribute.
                setattr(self.model, "name", "NewModel")

            print("Model name  has been changed.")
            self.print_model_info("After changing model")

        return circuit
